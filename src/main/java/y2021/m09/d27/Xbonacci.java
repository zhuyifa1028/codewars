package y2021.m09.d27;

import java.util.Arrays;

/**
 * Tribonacci数列
 */
public class Xbonacci {

    /**
     * 很好地遇到了斐波那契大哥，AKA Tribonacci。
     * <p>
     * 顾名思义，它的工作原理基本上类似于斐波那契数列，但将序列的最后 3 个（而不是 2 个）数字相加以生成下一个。而且，更糟糕的是，遗憾的是我不会听到非意大利语母语人士试图发音:(
     * <p>
     * 因此，如果我们以 [1, 1, 1] 作为起始输入（AKA 签名）开始我们的 Tribonacci 序列，我们有这个序列：
     * <p>
     * [1, 1 ,1, 3, 5, 9, 17, 31, ...]
     * 但是如果我们以 [0, 0, 1] 作为签名开始呢？由于从 [0, 1] 开始而不是 [1, 1] 基本上将常见的斐波那契数列移动了一个位置，您可能会认为我们会将相同的序列移动 2 个位置，但事实并非如此，并且我们会得到：
     * <p>
     * [0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
     * 好吧，您现在可能已经猜到了，但要清楚：您需要创建一个斐波那契函数，该函数给定一个签名数组/列表，返回前 n 个元素 - 包含在如此种子序列中的签名。
     * <p>
     * 签名将始终包含 3 个数字； n 总是一个非负数；如果 n == 0，则返回一个空数组（在 C 中返回 NULL 除外）并准备好其他任何未明确指定的内容；)
     * <p>
     * 如果你喜欢这个 kata 更高级和更通用的版本，可以在 Xbonacci kata 中找到
     *
     * @param s 初始数组
     * @param n 最终数组长度
     * @return 最终数组
     */
    public static double[] tribonacci(double[] s, int n) {
        double[] res = Arrays.copyOf(s, n);
        for (int i = 3; i < n; i++) {
            res[i] = res[i - 1] + res[i - 2] + res[i - 3];
        }
        return res;
    }

}
